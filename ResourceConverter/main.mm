//
//  main.mm
//  ResourceConverter
//
//  Copyright © 2016-2017 vit9696. All rights reserved.
//

//This file is a shameful terribly written copy-paste-like draft with minimal error checking if at all
//TODO: Rewrite this completely

#import <Foundation/Foundation.h>
#import <Cocoa/Cocoa.h>
#include <initializer_list>

#define SYSLOG(str, ...) printf("ResourceConverter: " str "\n", ## __VA_ARGS__)
#define ERROR(str, ...) do { SYSLOG(str, ## __VA_ARGS__); exit(1); } while(0)
NSString *ResourceHeader {@"\
//                                                   \n\
//  kern_resources.cpp                               \n\
//  Shiki                                            \n\
//                                                   \n\
//  Copyright © 2016-2017 vit9696. All rights reserved.   \n\
//                                                   \n\
//  This is an autogenerated file!                   \n\
//  Please avoid any modifications!                  \n\
//                                                   \n\n\
#include \"kern_resources.hpp\"                      \n\n"
};

NSString *ResourcePrivHeader {@"\
//                                                   \n\
//  kern_resources.hpp                               \n\
//  Shiki                                            \n\
//                                                   \n\
//  Copyright © 2016-2017 vit9696. All rights reserved.   \n\
//                                                   \n\
//  This is an autogenerated file!                   \n\
//  Please avoid any modifications!                  \n\
//                                                   \n\n\
#include <Headers/kern_user.hpp>                     \n\
#include <stdint.h>                                  \n\n\
extern UserPatcher::BinaryModInfo ADDPR(binaryMod)[];\n\
extern const size_t ADDPR(binaryModSize);            \n\n\
extern UserPatcher::ProcInfo ADDPR(procInfo)[];      \n\
extern const size_t ADDPR(procInfoSize);             \n\n"
//extern const uint32_t minProcLength;                 \n"
};

static void appendFile(NSString *file, NSString *data) {
	NSFileHandle *handle = [NSFileHandle fileHandleForUpdatingAtPath:file];
	[handle seekToEndOfFile];
	[handle writeData:[data dataUsingEncoding:NSUTF8StringEncoding]];
	[handle closeFile];
}

static NSString *generatePatchEntries(NSString *file, NSArray *patches) {
	static size_t patchIndex {0};
	static size_t patchBufIndex {0};
	
	if (patches) {
		auto pStr = [[NSMutableString alloc] initWithFormat:@"static UserPatcher::BinaryModPatch patches%zu[] {\n", patchIndex];
		auto pbStr = [[NSMutableString alloc] init];
		for (NSDictionary *p in patches) {
			NSData *f[] = {[p objectForKey:@"Find"], [p objectForKey:@"Replace"]};
			
			if ([f[0] length] != [f[1] length]) {
				[pStr appendString:@"#error not matching patch lengths\n"];
				continue;
			}
			
			for (auto d : f) {
				[pbStr appendString:[[NSString alloc] initWithFormat:@"alignas(8) static const uint8_t patchBuf%zu[] { ", patchBufIndex]];
				
				for (size_t b = 0; b < [d length]; b++) {
					[pbStr appendString:[[NSString alloc] initWithFormat:@"0x%0.2X, ", reinterpret_cast<const uint8_t *>([d bytes])[b]]];
				}
				
				[pbStr appendString:@"};\n"];
				
				patchBufIndex++;
			}
			
			[pStr appendFormat:@"\t{ %@, patchBuf%zu, patchBuf%zu, %zu, %@, %@, Section%@ },\n",
			 [p objectForKey:@"CPU"],
			 patchBufIndex-2,
			 patchBufIndex-1,
			 [f[0] length],
			 [p objectForKey:@"Skip"] ?: @"0",
			 [p objectForKey:@"Count"],
			 [p objectForKey:@"Section"]
			 ];
		}
		[pStr appendString:@"};\n"];
		
		appendFile(file, pbStr);
		appendFile(file, pStr);
		patchIndex++;
		return [[NSString alloc] initWithFormat:@"patches%zu, %lu", patchIndex-1, [patches count]];
	}
	
	return @"nullptr, 0";
}

static void generateMods(NSString *file, NSString *header, NSArray *modInfos) {
	auto sections = [[NSMutableDictionary alloc] init];
	auto sectionList = [[NSMutableString alloc] initWithUTF8String:"\n// Section list\n\nenum : uint32_t {\n"];
	size_t sectionIndex = 1;
	uint32_t allSections = 0;
	
	[sectionList appendString:@"\tSectionUnused = 0,\n"];
	for (NSDictionary *entry in modInfos) {
		NSArray *patches = [entry objectForKey:@"Patches"];
		for (NSDictionary *patch in patches) {
			if (![sections objectForKey:[patch objectForKey:@"Section"]]) {
				[sectionList appendFormat:@"\tSection%@ = %lu,\n", [patch objectForKey:@"Section"], sectionIndex];
				[sections setObject:@"ok" forKey:[patch objectForKey:@"Section"]];
				allSections |= sectionIndex;
				sectionIndex++;
			}
		}
	}
	
	[sectionList appendFormat:@"\tSectionAll = %u,\n};\n", allSections];
	appendFile(header, sectionList);
	
	appendFile(file, @"\n// Patch section\n\n");
	
	auto modSection = [[NSMutableString alloc] initWithUTF8String:"\n// Mod section\n\n"];
	
	[modSection appendString:@"UserPatcher::BinaryModInfo ADDPR(binaryMod)[] {\n"];
	
	for (NSDictionary *entry in modInfos) {
		NSArray *patches = [entry objectForKey:@"Patches"];
		[modSection appendFormat:@"\t{ \"%@\", %@ },\n",
			[entry objectForKey:@"Path"], generatePatchEntries(file, patches)];
	}
	
	[modSection appendString:@"};\n"];
	[modSection appendFormat:@"\nconst size_t ADDPR(binaryModSize) {%lu};\n", [modInfos count]];
	appendFile(file, modSection);
}

static void generateComparison(NSString *file, NSArray *binaries) {
	auto procSection = [[NSMutableString alloc] initWithUTF8String:"\n// Process list\n\n"];
	NSUInteger minProcLength {PATH_MAX};
	
	[procSection appendString:@"UserPatcher::ProcInfo ADDPR(procInfo)[] {\n"];
	for (NSDictionary *entry in binaries) {
		auto len = [[entry objectForKey:@"Path"] length];
		[procSection appendFormat:@"\t{ \"%@\", %lu, Section%@ },\n",
			[entry objectForKey:@"Path"], len, [entry objectForKey:@"Section"]];
		if (len < minProcLength)
			minProcLength = len;
	}
	[procSection appendString:@"};\n"];
	[procSection appendFormat:@"\nconst size_t ADDPR(procInfoSize) {%lu};", [binaries count]];
	//[procSection appendFormat:@"\nconst uint32_t minProcLength {%lu};\n",  minProcLength];
	
	
	appendFile(file, procSection);
}

int main(int argc, const char * argv[]) {
	if (argc != 4)
		ERROR("Invalid usage");
	
	auto basePath = [[NSString alloc] initWithUTF8String:argv[1]];
	auto patchesCfg = [[NSString alloc] initWithFormat:@"%@/Patches.plist", basePath];
	auto outputCpp = [[NSString alloc] initWithUTF8String:argv[2]];
	auto outputHpp = [[NSString alloc] initWithUTF8String:argv[3]];
	
	auto patches = [NSDictionary dictionaryWithContentsOfFile:patchesCfg];
	
	if (!patches)
		ERROR("Missing resource data");
	
	// Create a file
	[[NSFileManager defaultManager] createFileAtPath:outputCpp contents:nil attributes:nil];
	[[NSFileManager defaultManager] createFileAtPath:outputHpp contents:nil attributes:nil];
	
	appendFile(outputCpp, ResourceHeader);
	appendFile(outputHpp, ResourcePrivHeader);
	generateMods(outputCpp, outputHpp, [patches objectForKey:@"Patches"]);
	generateComparison(outputCpp, [patches objectForKey:@"Processes"]);
}
